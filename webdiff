#!/usr/bin/ruby
# (C) 2004,2007, Stephan Beyer, GNU GPL
#
# requirements:
#	* ruby standard distribution (net::http, uri, pstore, getoptlong)
#	  http://www.ruby-lang.org (at least version 1.8)
# recommended:
#	* GNU readline for ruby (for interactive configuration)
# wishlist/todo?
#	* https, ftp
#	* nicer code ;)
# Please tell me if you find any bugs: Stephan Beyer <s-beyer@gmx.net>
# You may also tell me your thoughts/ideas/opinion about this tool.

ProgName = 'webdiff'
ProgVersion = '20070319'
WorkDir = ENV['HOME']+'/.'+ProgName+'/'
DefaultTimeout = 20
DefaultTest = 'diff'
DefaultContext = 3

$errors = 0

def showversion
	puts "#{ProgName} #{ProgVersion}\t\t(C) 2004, 2007 Stephan Beyer, GNU GPL"
end
def showusage
	puts <<-EOU

Usage:	#{$0} [option]

Option can be one of:
	--configure, -c		Reconfigure #{ProgName}
	--diff, -d		Print the current differences
	--help, -h		Print this help
	--reset, -r		Reset current differences
	--version, -v		Print current version

Further options are ignored.
See the manual page `man 1 #{ProgName}'.

Have fun!
	EOU
end

def name(test, url, suffix=nil)
	if suffix.nil?
		test+'::'+url
	else
		test+'::'+url+'::'+suffix
	end
end

$gnu =	begin
	require 'readline'
	true
rescue LoadError
	false
end
def readln(str = '')
	if $gnu
		Readline.readline(str, true)
	else
		print str
		STDIN.gets.chomp
	end
end

def str_to_re(str)
	eval('%r'+str) ## FIXME this is eval^Wevil!
# How can this be fixed?
# See this #ruby-lang log:
# <apeiros> try yaml.
# <apeiros> {:regex1 => /foo/i, :regex2 => /bar/u}.to_yaml # => "--- 
#           \n:regex2: !ruby/regexp /bar/u\n:regex1: !ruby/regexp /foo/i\n"
# <apeiros> regexen are slightly uncomfortable, but most stuff is human readable 1:1
# <sbeyer> apeiros, ok, thank you, it's noticed. And is there a way if I don't want 
#          to change the format? ;-)
# <apeiros> the obvious: eval or split the expression and use Regexp.new
end

class Store
	require 'pstore'
	def initialize
		@db = PStore.new(WorkDir+'store')
	end
	def each
		@db.transaction do
			@db.roots.each do |*args|
				yield(*args)
			end
		end
	end
	def [](key)
		@db.transaction(true) do @db[key] end
	end
	def []=(key,value)
		@db.transaction do @db[key]=value end
	end
	def delete(key)
		@db.delete(key)
	end
end

class Config
	def initialize
		@glob = {}
		@conf = [{}]
		begin
			readconfigfile
		rescue SystemCallError
			$log.puts($!)
			$log.puts('configuring')
			configure
			exit
		end
	end
	def each(&block)
		@conf.each(&block)
	end
	def [](key)
		if key.class == String
			@glob[key]
		else
			@conf[key]
		end
	end

	def readconfigfile
		i = 0
		File.open(WorkDir+'config', 'r') do |conffile|
			conffile.each_line do |line|
				line.strip!
				if line =~ /^#/ or line.empty?
					next
				elsif line =~ /^\+/
					k, v = line[1..-1].strip.split(/\s+/, 2)
					@conf[i].merge!({k=>v})
				else
					i += 1
					@conf << {'url'=>(line=~%r(^http://) ? '':'http://')+line}
					# FIXME what about https://?
				end
			end
		end
		@glob = @conf.shift
	end

	def configure(reconfigure=false)
		@conf.unshift(@glob) if reconfigure
		showversion
		print <<-EOD

This is the #{ProgName} #{ProgVersion} interactive configuration tool.
#{ProgName} uses a simple human-readable configuration file
	#{WorkDir+'config'}
but you can always use this tool by executing `#{$0} -c' 
on the command line.
		EOD
		if configure_mainmenu # save config
			File.open(WorkDir+'config', 'w') do |out|
				out.print <<-EOH
# #{ProgName} configuration file, type `#{ProgName} -c' to configure
# Format:
# # comment
# + <globalvariable> <globalvalue>
# <url1>
# + <variable> <value>
# + ...
# <url2>
# ...
#
# variables are: client, lang, proxy, referer, test, timeout, range
# <test> can be html, diff, size, date, md5sum or a <regexp>
# diff is the default. proxy must be in the format <host>:<port>
# 
# 'diff'/'html' test modes have two extra variables:
# start <start regexp>		and		end <end regexp>	
# These two are nice for dynamic web pages with a more interesting static 
# part. Set start and end regexp, and then #{ProgName} only diffs the content
# between the first 'start' and the last 'end' match, and not a change 
# like "xx users online" or a random (fortune) server signature.
#
# All variable settings are optional.
# Have fun! sbeyer
				EOH
				@conf.each do |e|
					out.puts "\n"+e['url'] unless e['url'].nil?
					out.puts "  + test\t"+e['test'] unless e['test'].nil?
					out.puts "  + client\t"+e['client'] unless e['client'].nil?
					out.puts "  + referer\t"+e['referer'] unless e['referer'].nil?
					out.puts "  + lang\t"+e['lang'] unless e['lang'].nil?
					out.puts "  + range\t"+e['range'] unless e['range'].nil?
					out.puts "  + timeout\t"+e['timeout'] unless e['timeout'].nil?
					out.puts "  + proxy\t"+e['proxy'] unless e['proxy'].nil?
					if ['html','diff'].member?(e['test'])
						out.puts "  + start\t"+e['start'] unless e['start'].nil?
						out.puts "  + end \t"+e['end'] unless e['end'].nil?
					end
				end
			end
		end
	end
	def configure_mainmenu
		loop do
			puts "\n\n"
			possible = ['n', 'f', 'x']
			@conf.each_with_index do |e, c|
				print "  [#{c}]\t"
				possible << c.to_s
				if c == 0
					puts 'Global settings'
				else
					puts e['url']+' specific settings'
				end
			end
			puts "  [n]\tAdd new URL"
			puts
			puts "  [f]\tFinished (exit & save)"
			puts "  [x]\tExit without saving"
			case (c = choose(possible))
				when 'f'
					return true
				when 'x'
					return false
				when 'n'
					nr = @conf.length
					configure_url(nr)
					configure_testmethod(nr)
				else
					configure_urlmenu(c.to_i)
			end
		end
	end

	def choose(possible)
		puts
		choice = readln("  Your choice [#{possible.join('/')}]: ") until possible.member?(choice)
		puts "\n"
		choice
	end

	def ask_regexp
		puts "\n"+'Please type the regexp, e.g. /[Hh]ugo\s+wrote/ ...'
		begin
			re = readln
			str_to_re(re)
		rescue SyntaxError
			puts 'Incorrect regular expression! Try again:'
			retry
		end
		re
	end

	def configure_url(nr)
		puts "\nPlease type the correct URI of the web page you want to check for updates:"
		if @conf[nr].nil?
			@conf[nr] = {'url'=>readln('> ')}
		else
			@conf[nr]['url'] = readln('> ')
		end
	end
	def configure_testmethod(nr)
		puts <<-EOD

Choose the TEST METHOD, the way of looking for changes. Type:
	diff	This method downloads the whole file and saves the two 
		last versions. Use the -d option to take a look at a diff 
		of these versions.
	html	This method acts like 'diff', but ignores text between
		'<' and '>' on diffing. (Those usually denote HTML tags.)
	size	This method downloads the HTTP header to check if the file
		size changes. The server should response the Content-Length
		header entity. (works in most cases)
	date	This method downloads the HTTP header to check when the file
		was last modified. This behaviour can cause problems when
		fetching some dynamic web sites. The server should response
		the Last-Modified header entity. (works in most cases)
	md5sum	This method downloads the HTTP header to check if the MD5 sum
		changes. The server should response the Content-MD5 header
		entity to make this method work.
	regexp	This method downloads the whole file and checks if a given
		regexp matches. Nothing is stored locally.
		EOD
		@conf[nr]['test'] = choose(['diff','html','size','date','md5sum','regexp'])
		@conf[nr]['test'] = ask_regexp if @conf[nr]['test'] == 'regexp'
	end
	def configure_useragent(nr)
		puts "\nType an User-Agent identification string:"
		@conf[nr]['client'] = readln
	end
	def configure_referer(nr)
		puts "\nType the suggested URL of the Referer[sic]:"
		@conf[nr]['referer'] = readln
	end
	def configure_lang(nr)
		puts "\nType your language code, e.g de, ca or en:"
		@conf[nr]['lang'] = readln
	end
	def configure_range(nr)
		# This option only makes sense when using the DIFF method
		puts
		puts 'Note: You should NOT use this option globally.' if nr==0
		puts 'Not all HTTP servers support this feature.'
		puts <<-EOH
Type a range. Examples:
	 0-99	= get the first 100 bytes (byte 0 to byte 99)
	  -99	= get the last 99 bytes
	99-99	= get the 99th byte
	99-	= get all bytes, beginning with the 99th
	65-923	= get bytes 65 to 923
		EOH
		begin
			@conf[nr]['range'] = readln('> ')
		end until (@conf[nr]['range'] =~ /^\d*-\d*$/) or
		           @conf[nr]['range'].empty?
	end
	def configure_timeout(nr)
		puts "\nConnection timeout in seconds:"
		@conf[nr]['timeout'] = readln
	end
	def configure_proxy(nr)
		puts "\nWhat is host and port of your HTTP proxy? Format: host:port"
		begin
		@conf[nr]['proxy'] = readln('http://')
		end until (@conf[nr]['proxy'] =~ /^[\w\.-]+:\d+$/) or
		           @conf[nr]['proxy'].empty?
	end
	def configure_urlmenu(nr)
		loop do
			puts "\n\n"
			if nr == 0 then
				possible=[]
				puts "  [ ]\tGlobal"
			else
				possible=['u']
				puts "  [u]\tURL: #{@conf[nr]['url']}"
			end
			puts "  [m]\tTest method: #{@conf[nr]['test']}"
			puts
			puts "  [a]\tUser-Agent: #{@conf[nr]['client']}"
			puts "  [r]\tReferer: #{@conf[nr]['referer']}"
			puts "  [l]\tAccept-Language: #{@conf[nr]['lang']}"
			puts "  [b]\tRange: #{@conf[nr]['range']}"
			puts "  [t]\tTimeout: #{@conf[nr]['timeout']}"
			puts "  [p]\tProxy: #{@conf[nr]['proxy']}"
			possible += ['m', 'a', 'r', 'l', 'b', 't', 'p']
			if ['html','diff'].member?(@conf[nr]['test']) and nr != 0
				puts "  [s]\tStart regexp: #{@conf[nr]['start']}"
				puts "  [e]\tEnd regexp: #{@conf[nr]['end']}"
				possible += ['s', 'e']
			end
			puts

			if nr > 0
				puts "  [d]\tDelete URL from list."
				possible << 'd'
			end
			puts "  [f]\tI have finished."
			possible << 'f'
			case (choice = choose(possible))
				when 'u' then configure_url(nr)
				when 'm' then configure_testmethod(nr)
				when 'a' then configure_useragent(nr)
				when 'r' then configure_referer(nr)
				when 'l' then configure_lang(nr)
				when 'b' then configure_range(nr)
				when 't' then configure_timeout(nr)
				when 'p' then configure_proxy(nr)
				when 's' then @conf[nr]['start'] = ask_regexp
				when 'e' then @conf[nr]['end'] = ask_regexp
				when 'd'
					@conf.delete_at(nr)
					return
				when 'f' then return
			end
		end
	end
end

class Main
	def initialize
		@config = Config.new
		@store = Store.new
		cleanup
	end

	def getconf(e, key)
		# return e[key]'s value
		# if not set return global value
		# if not set return default value or nil
		if not e[key].nil?
			e[key]
		elsif @config[key].nil?
			case key
				when 'test' then DefaultTest
				when 'timeout' then DefaultTimeout
				else nil
			end
		else
			@config[key]
		end
	end

	def cleanup
		@store.each do |key|
			verify = false
			@config.each do |e|
				verify = true if key == name(getconf(e, 'test'), e['url'], getconf(e,'range'))
			end
			unless verify
				@store.delete(key)
				$log.puts "deleted stored `#{key}' data"
			end
		end
	end
end

# the following module code has been taken from:
# 	libalgorithm-diff-ruby version 0.4
# and has been changed.
# 
# Original copyright notice:
# # algorithm/diff - a Ruby module to compute difference sets between two
# # objects. Copyright (c) 2001-2002 Lars Christensen.
# #
# #  This program is free software; you can redistribute it and/or modify
# # it under the terms of the GNU General Public License as published by
# # the Free Software Foundation; either version 2 of the License, or
# # (at your option) any later version.
# #
# # This program is distributed in the hope that it will be useful, but
# # WITHOUT ANY WARRANTY; without even the implied warranty of
# # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# # General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation, 
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
module Diff
	attr_reader :diffs

	# Change notes:
	# The mix-in module Diffable has been removed.
	# The functions reverse_hash and replacenextlarger have been put here.
	# The lcs function has just been copied, reindented and reverse_hash / 
	# replacenextlarger changes have been applied.
	# makediff has been altered to yield both indices and no string. (This is not
	# really needed, but more `natural' in my opinion.)
	# diff has been rewritten to produce a imho `nicer' output.
	# groupwise and unified have been completely written by me (sbeyer) and are
	# not part of the original libalgorithm-diff-ruby package.
	
	# Create a hash that maps elements of the array to arrays of indices
	# where the elements are found.
	def Diff.reverse_hash(obj, range = (0...obj.length))
		revmap = {}
		range.each do |i|
			elem = obj[i]
			if revmap.has_key? elem
				revmap[elem].push i
			else
				revmap[elem] = [i]
			end
		end
		revmap
	end
	
	# Replace the first element of obj which is larger than value. Assumes that
	# the element indexed by high, if given is larger than value.
	def Diff.replacenextlarger(obj, value, high = nil)
		high ||= obj.length
		low = 0
		index = found = nil
		while low < high
			index = (high+low) >> 1
			found = obj[index]
			if value > found		# this first, most common case
				low = index + 1
			elsif value == found
				return nil
			else
				high = index
			end
		end
		obj[low] = value
		low
	end

	def Diff.lcs(a, b)
		astart = 0
		bstart = 0
		afinish = a.length-1
		bfinish = b.length-1
		mvector = []

		# First we prune off any common elements at the beginning
		while (astart <= afinish && bstart <= afinish && a[astart] == b[bstart])
			mvector[astart] = bstart
			astart += 1
			bstart += 1
		end

		# now the end
		while (astart <= afinish && bstart <= bfinish && a[afinish] == b[bfinish])
			mvector[afinish] = bfinish
			afinish -= 1
			bfinish -= 1
		end

		bmatches = reverse_hash(b, bstart..bfinish)
		thresh = []
		links = []

		(astart..afinish).each do |aindex|
			aelem = a[aindex]
			next unless bmatches.has_key? aelem
			k = nil
			bmatches[aelem].reverse_each do |bindex|
				if k && (thresh[k] > bindex) && (thresh[k-1] < bindex)
					thresh[k] = bindex
				else
					k = replacenextlarger(thresh, bindex, k)
				end
				links[k] = [ k!=0 && links[k-1], aindex, bindex ] if k
			end
		end

		if !thresh.empty?
			link = links[thresh.length-1]
			while link
				mvector[link[1]] = link[2]
				link = link[0]
			end
		end

		return mvector
	end

	def Diff.makediff(a, b)
		mvector = Diff.lcs(a, b)
		ai = bi = 0
		while ai < mvector.length
			bline = mvector[ai]
			if bline
				while bi < bline
					yield :+, ai, bi
					bi += 1
				end
				bi += 1
			else
				yield :-, ai, bi
			end
			ai += 1
		end
		while ai < a.length
			yield :-, ai, bi
			ai += 1
		end
		while bi < b.length
			yield :+, ai, bi
			bi += 1
		end
		1
	end

	def Diff.diff(a, b, &block)
		diffs = [[:info, a.length, b.length]] # dirty trick
		block ||= proc do |action, li, ri|
			diffs << [action, li, ri]
		end
		Diff.makediff(a, b, &block)
		diffs
	end

	# group diff by context
	def Diff.groupwise(diff, context)
		(_,alen,blen) = diff.shift # dirty trick to get length information
		groups = [] # array of groups

		unless diff.empty?
			g = [] # one group
			low = 0
			(el0,el1,el2) = diff.shift

			begin
				[low, el1-context].max.upto(el1-1) do |i|
					g.push [:eq, i, i+el2-el1]
				end
				begin
					g.push [el0,el1,el2]
					low = el1
					low += 1 if el0 == :-
					
					if diff.empty?
						el1 = blen
						low.upto([low+context,alen].min-1) do |i|
							g.push [:eq, i, i+blen-alen]
						end
						break
					else
						(el0,el1,el2) = diff.shift
						low.upto([el1,low+context].min-1) do |i|
							g.push [:eq, i, i+el2-el1]
						end
					end
				end while el1 - low <= context

				if el1 - low <= 2*context and el1 != blen
					low += 2 # didn't figure out why, but this
					         # worked on all examples!
					next
				end

				groups.push g
				yield g
				g = []
			end until diff.empty?
		end
		groups
	end

	def Diff.unified(la,ra,context=3)
		groupwise(diff(la,ra),context) do |g|
			# count :- and :+
			minus = g.find_all do |z| z[0]==:- end.length
			plus = g.find_all do |z| z[0]==:+ end.length
			equal = g.length - minus - plus
			minus += equal
			plus += equal

			str = '@@ -'
			if minus > 1
				str << "#{g[0][1]+1},#{minus}"
			elsif minus == 1
				str << (g[0][1]+1).to_s
			else # minus == 0
				str << "#{g[0][1]},0"
			end
			str << ' +'
			if plus > 1
				str << "#{g[0][2]+1},#{plus}"
			elsif plus == 1
				str << (g[0][2]+1).to_s
			else # plus == 0
				str << "#{g[0][2]},0"
			end
			str << " @@\n"
			yield str

			g.each do |x|
				if x[0] == :eq then
					str = ' '+la[x[1]]
				elsif x[0] == :- then
					str = '-'+la[x[1]]
				else
					str = '+'+ra[x[2]]
				end
				yield str
			end
		end
	end
end

class MainDiff < Main
	def initialize
		super
		@config.each do |e|
			method = getconf(e, 'test')
			next unless ['diff','html'].member?(method)
			key = name(method, e['url'], getconf(e, 'range'))
			list = @store[key]
			next if list.nil?
			next if list[0] == list[1]
			puts '--- '+e['url']
			puts '+++ '+e['url']
			file1, file2 = [], []
			list[0].each_line do |line| file1 << line end
			list[1].each_line do |line| file2 << line end
			Diff.unified(file1,file2,DefaultContext) do |str|
				print str
			end
		end
	end
end

class MainReset < Main
	def initialize
		super
		@config.each do |e|
			method = getconf(e, 'test')
			next unless ['diff','html'].member?(method)
			key = name(method, e['url'], getconf(e, 'range'))
			list = @store[key]
			next if list.nil?
			next if list[0] == list[1]
			list[0] = list[1]
			@store[key] = list
		end
	end
end

class MainConfigure < Main
	def initialize
		super
		@config.configure true
	end
end

class MainGet < Main
	require 'net/http'
	require 'uri'

	def initialize
		super
		fetchurls
	end

	def updatedata(key, value)
		if value.nil?
			$log.puts "#{key} - not set! choose another test method!"
			return
		end
		unless @store[key].nil? or value == @store[key]
			yield
			$log.puts "#{key} - changed"
		end
		@store[key] = value
	end

	def diffdata(key, value)
		if @store[key].nil?
			@store[key] = [value, value]
			$log.puts "#{key} - set"
		else
			if @store[key][1] != value
				@store[key] = [@store[key][1], value]
				yield
				$log.puts "#{key} - changed"
			end
		end
	end

	# simple regular <.*> matcher and remover.
	# Could fail on nested <tags>, on wrong HTML and on Javascript.
	def tagstrip(str)
		str.gsub(/([\r\n]|<[^<>]*>)+/,"\n").gsub(/[ \t]+/,' ').gsub(/([\r\n][ \t]+)+[\r\n]?/, "\n")
	end

	# cuts out string between first match to "starts" (a regexp string or 
	# nil) and last match to "ends" (regexp string or nil)
	def cutout(starts, ends, str)
		unless starts.nil?
			begin
				match = str.match(str_to_re(starts))
			rescue SyntaxError
				$log.puts "Error on parsing start regex \"#{starts}\"."
				$log.puts $!
				raise
			end
			match = str.match(str_to_re(starts))
			str = str[match.begin(0)..-1] unless match.nil?
		end
		unless ends.nil?
			pos = 0
			begin
				begin
					match = str[pos..-1].match(str_to_re(ends))
				rescue SyntaxError
					$log.puts "Error on parsing end regex \"#{ends}\"."
					$log.puts $!
					raise
				end
				match = str[pos..-1].match(str_to_re(ends))
				pos += match.end(0) unless match.nil?
			end until match.nil?
			str = str[0..pos-1]
		end
		str += "\n" unless [?\n,?\r].member?(str[-1])
		str
	end

	def fetchurls
		@config.each do |e|
			begin
				url = URI.parse(e['url'])
				todo = proc { puts url }
				header = {}
				header['User-Agent'] = getconf(e, 'client') unless getconf(e, 'client').nil?
				header['Referer'] = getconf(e, 'referer') unless getconf(e, 'referer').nil?
				header['Accept-Language'] = getconf(e, 'lang') unless getconf(e, 'lang').nil?
				header['Range'] = 'bytes='+getconf(e, 'range') unless getconf(e, 'range').nil?
				header['Authorization'] ='Basic '+[url.userinfo].pack('m') unless url.userinfo.to_s.empty?
				header['Connection'] = 'close' # default
				header['Cache-Control'] = 'no-cache' # Thanks to Alexander Logvinov!
				header['Pragma'] = 'no-cache' # this, too
				proxy, proxyport = getconf(e, 'proxy').split(/:/) unless getconf(e, 'proxy').nil?
				proxyport = proxyport.to_i unless proxyport.nil?
				timeout = getconf(e, 'timeout')
				method = getconf(e, 'test')
				path = '/'
				path = url.path unless url.path.to_s.empty?
				path << '?'+url.query unless url.query.to_s.empty?

				conn = Net::HTTP.new(url.host, url.port, proxy, proxyport) # you can add "proxyuser", "proxypass" strings for proxy auth
				conn.open_timeout = timeout.to_i
				conn.start do
					resp = {}
					if ['size','md5sum','date'].member?(method)
						resp = conn.head(path, header) # only need header (HEAD request)
						case method
							when 'size'
								updatedata(name(method,e['url']), resp['Content-Length'], &todo)
							when 'md5sum'
								updatedata(name(method,e['url']), resp['Content-MD5'], &todo)
							when 'date'
								updatedata(name(method,e['url']), resp['Last-Modified'], &todo)
						end
					else
						resp = conn.get(path, header) # get body (GET request)
						if method == 'diff'
							begin
								diffdata(name(method, e['url'], getconf(e, 'range')), cutout(e['start'],e['end'], resp.body), &todo)
							rescue SyntaxError
								$errors += 1
							end
						elsif method == 'html'
							begin
								diffdata(name(method, e['url'], getconf(e, 'range')), tagstrip(cutout(e['start'],e['end'], resp.body)), &todo)
							rescue SyntaxError
								$errors += 1
							end
						else
							begin
								if resp.body =~ str_to_re(method)
									todo.call
								end
							rescue SyntaxError
								$log.puts "Error on parsing regex \"#{method}\"."
								$log.puts $!
								$errors += 1
							end
						end
					end
				end
			rescue SocketError, Timeout::Error, URI::InvalidURIError
				$log.puts e['url']+': '+$!
				$errors += 1
			end
		end
	end
end

Dir.mkdir(WorkDir) unless File.exist?(WorkDir)
$log = File.new(WorkDir+'lastlog', 'w')
END {
	$log.close
}

# options
case ARGV[0]
	when '--configure', '-c'
		MainConfigure.new
	when '--diff', '-d'
		MainDiff.new
	when '--help', '-h'
		showversion
		showusage
	when '--reset', '-r'
		MainReset.new
	when '--version', '-v'
		showversion
	else
		MainGet.new
		#begin
		#	MainGet.new
		#rescue StandardError
		#	$log.puts $!
		#	$errors += 1
		#end
		### this is nicer, but ugly for bug reporting!
end
exit $errors
